{"type":"cy:bean","properties":{"beanType@STRING":"cy:requiremodule","name@STRING":"Class","script@STRING":"var Class = function() {};\r\nClass.extend = function(subClassDefinition) {\r\n\tvar subClass = function() {\r\n\t\tif (arguments[0] !== Class) {\r\n\t\t\t// call a custom constructor named \"construct\"\r\n\t\t\t\t\t\t\tif(!this.construct) {\r\n\t\t\t\t\t\t\t\tconsole.error(\"executing constructor in wrong prototype\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\tthis.construct.apply(this, arguments);\r\n\t\t}\r\n\t};\r\n\r\n\t// create a new Class prototype\r\n\t// this is our subclass stub\r\n\tvar proto = new this(Class);\r\n\r\n\t// if we call extend from a Class object, the Class objects prototype will be the superclass\r\n\tvar superClass = this.prototype;\r\n\r\n\t// for all functions declared for the subclass\r\n\tfor (var n in subClassDefinition) {\r\n\t\tvar item = subClassDefinition[n];\r\n\t\tif (typeof(item) === \"function\") {\r\n\t\t\t// set the $parent attribute on the function object to the parent superclass\r\n\t\t\t// this will allow to get from one superclass to another. using \"this.$parent\" inside a function will lead to invocation circles.\r\n\t\t\titem.$parent = superClass;\t\r\n\t\t\titem.$name = n;\r\n\t\t}\r\n\t\tproto[n] = item;\r\n\t}\r\n\t\r\n\t// a convenience method to invoke super function implementations\r\n\tproto[\"invokeSuper\"] = function(arg) {\r\n\t\tvar name = arg.callee.$name;\r\n\t\tif(name) {\r\n\t\t\tvar p = arg.callee.$parent[name];\r\n\t\t\tif(p) {\r\n\t\t\t\tp.apply(this, arg);\t\t\r\n\t\t\t} else {\r\n\t\t\t\tconsole.warn(\"could not invoke super implementation of '\"+name+\"', because there was function with that name in the super type.\");\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tconsole.error(\"could not invoke super, because function was not passed through Class prototype.\");\r\n\t\t}\r\n\t};\r\n\t\r\n\tproto[\"callSuper\"] = function() {\r\n\t\tvar arg = arguments[0], // arguments of the invocation block that calls \"callSuper\"\r\n\t\targs = []; // the actual arguments\r\n\t\t\r\n\t\tfor(var i=1; i < arguments.length; i++){\r\n\t\t\targs.push(arguments[i]);\r\n\t\t}\r\n\t\tvar name = arg.callee.$name;\r\n\t\tif(name) {\r\n\t\t\tvar p = arg.callee.$parent[name];\r\n\t\t\tif(p) {\r\n\t\t\t\tp.apply(this, args);\t\t\r\n\t\t\t} else {\r\n\t\t\t\tconsole.warn(\"could not invoke super implementation of '\"+name+\"', because there was function with that name in the super type.\");\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tconsole.error(\"could not invoke super, because function was not passed through Class prototype.\");\r\n\t\t}\r\n\t};\r\n\r\n\t// now the created subclass gets his customized prototype\r\n\t// remember: the customizing pimped each function with a reference to the super class\r\n\tsubClass.prototype = proto;\r\n\r\n\tsubClass.extend = this.extend;\r\n\treturn subClass;\r\n}\r\nreturn Class;","initMethod@STRING":"","proxy@STRING":""}}
