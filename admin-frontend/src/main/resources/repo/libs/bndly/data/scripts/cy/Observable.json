{"type":"cy:bean","properties":{"beanType@STRING":"cy:requiremodule","name@STRING":"Observable","dependencies@STRING":["/libs/bndly/data/scripts/cy/Class"],"script@STRING":"var Observable = Class.extend({\r\n\tconstruct: function(config) {\r\n\t\tif (!this) {\r\n\t\t\tthrow new Error(\"can not apply config to \" + this);\r\n\t\t}\r\n\r\n\t\tthis.initialConfig = config;\r\n\t\tthis._listenersOnOtherComponents = [];\r\n\t\tif (config) {\r\n\t\t\tfor (var k in config) {\r\n\t\t\t\tthis[k] = config[k];\r\n\t\t\t}\r\n\r\n\t\t\tthis.listeners = {};\r\n\t\t\tif (config.listeners) {\r\n\t\t\t\tfor (var i in config.listeners) {\r\n\t\t\t\t\tvar l = config.listeners[i];\r\n\t\t\t\t\tif (typeof(l) === \"function\") {\r\n\t\t\t\t\t\tthis.addListener(i, l);\r\n\t\t\t\t\t} else if (typeof(l) === \"object\") {\r\n\t\t\t\t\t\tthis.addListener(i, l.fn, l.scope);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\taddListener: function(eventName, callback, scope, maxInvocations) {\r\n\t\tif (!this.listeners) {\r\n\t\t\tthis.listeners = {};\r\n\t\t}\r\n\r\n\t\tif (!this.listeners[eventName]) {\r\n\t\t\tthis.listeners[eventName] = [];\r\n\t\t} else if (this.listeners[eventName] instanceof Array) {\r\n\t\t\t// do nothing\r\n\t\t} else if (this.listeners[eventName] instanceof Object) {\r\n\t\t\tthis.listeners[eventName] = [this.listeners[eventName]];\r\n\t\t} else if (this.listeners[eventName] instanceof Function) {\r\n\t\t\tthis.listeners[eventName] = [{\r\n\t\t\t\tfn: this.listeners[eventName]\r\n\t\t\t}];\r\n\t\t}\r\n\r\n\t\tvar listener = {\r\n\t\t\tfn: callback,\r\n\t\t\tscope: scope\r\n\t\t};\r\n\t\tthis.listeners[eventName].push(listener);\r\n\t\tif(maxInvocations) {\r\n\t\t\tlistener.invocations = maxInvocations\r\n\t\t}\r\n\r\n\t},\r\n\taddSingleInvocationListener: function(eventName, callback, scope) {\r\n\t\tthis.addListener(eventName, callback, scope, 1);\r\n\t},\r\n\tremoveListener: function(eventName, callback, scope) {\r\n\t\tif (this.listeners) {\r\n\t\t\tvar eventListeners = this.listeners[eventName];\r\n\t\t\tif (eventListeners) {\r\n\t\t\t\tif (eventListeners instanceof Array) {\r\n\t\t\t\t\tfor (var i in eventListeners) {\r\n\t\t\t\t\t\tvar listener = eventListeners[i];\r\n\t\t\t\t\t\tif (listener.fn === callback) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif((scope && listener.scope === scope) || !scope) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\teventListeners = eventListeners.splice(i, i);\r\n\t\t\t\t\t\t\tthis.listeners[eventName] = eventListeners;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (eventListeners instanceof Object) {\r\n\t\t\t\t\tif (eventListeners.fn === callback) {\r\n\t\t\t\t\t\tthis.listeners[eventName] = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (eventListeners instanceof Function) {\r\n\t\t\t\t\tif (eventListeners === callback) {\r\n\t\t\t\t\t\tthis.listeners[eventName] = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tfireEvent: function() {\r\n\t\tif (arguments.length < 1) {\r\n\t\t\tthrow new Error(\"can not invoke fireEvent without eventName parameter\");\r\n\t\t}\r\n\t\tvar eventName = arguments[0];\r\n\t\tif (this.listeners) {\r\n\t\t\tvar toInvoke = this.listeners[eventName];\r\n\t\t\tif (toInvoke) {\r\n\t\t\t\tvar allHandlers = [];\r\n\t\t\t\tif (toInvoke instanceof Array) {\r\n\t\t\t\t\tallHandlers = toInvoke;\r\n\t\t\t\t} else if (toInvoke instanceof Object) {\r\n\t\t\t\t\tallHandlers.push(toInvoke);\r\n\t\t\t\t} else if (toInvoke instanceof Function) {\r\n\t\t\t\t\tallHandlers.push({\r\n\t\t\t\t\t\tfn: toInvoke\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (var i in allHandlers) {\r\n\t\t\t\t\ttoInvoke = allHandlers[i];\r\n\t\t\t\t\tif (toInvoke.fn instanceof Function) {\r\n\t\t\t\t\t\tvar s = toInvoke.scope;\r\n\t\t\t\t\t\tif (!s) {\r\n\t\t\t\t\t\t\ts = this;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar args = [];\r\n\t\t\t\t\t\tfor (var a in arguments) {\r\n\t\t\t\t\t\t\targs.push(arguments[a]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(toInvoke.invocations === undefined || toInvoke.invocations > 0) {\r\n\t\t\t\t\t\t\ttoInvoke.fn.apply(s, args.slice(1));\r\n\t\t\t\t\t\t\tif(toInvoke.invocations !== undefined) {\r\n\t\t\t\t\t\t\t\ttoInvoke.invocations -= 1;\r\n\t\t\t\t\t\t\t\t// maybe some kind of clean up would be wise...\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tlisten: function(observable, event, callback, scope) {\r\n\t\t\t\tif(!observable) {\r\n\t\t\t\t\tconsole.warn(\"trying to attach listener to null or undefined\");\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\tobservable.addListener(event, callback, scope);\r\n\t\tthis._listenersOnOtherComponents.push({\r\n\t\t\tobservable: observable, \r\n\t\t\tevent: event, \r\n\t\t\tcallback: callback, \r\n\t\t\tscope: scope\r\n\t\t});\r\n\t},\r\n\tdestroy: function() {\r\n\t\tthis.fireEvent(\"beforeDestroy\", this);\r\n\t\tfor(var i in this._listenersOnOtherComponents) {\r\n\t\t\tvar descriptor =  this._listenersOnOtherComponents[i];\r\n\t\t\tdescriptor.observable.removeListener(descriptor.event, descriptor.callback);\r\n\t\t}\r\n\t}\r\n});\r\nreturn Observable;","initMethod@STRING":"","proxy@STRING":""}}
